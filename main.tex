% LTeX: language=pt-BR

\documentclass[10pt,oneside,onecolumn]{report}
\input{def.tex}

\title{{\huge\bfseries Rust: Uma An√°lise da Linguagem}\\
Linguagens de Programa√ß√£o}

\author{ % Autores
    \textsc{Amanda Canizela Guimar√£es} \\
    \normalsize{\href{mailto:amanda.canizela@gmail.com}{\texttt{amanda.canizela@gmail.com}}}
    \and
    \textsc{Ariel In√°cio Jord√£o Coelho} \\
    \normalsize{\href{mailto:arielijordao@gmail.com}{\texttt{arielijordao@gmail.com}}}
    \and
    \textsc{Lucca Pellegrini} \\
    \normalsize{\href{mailto:lucca@verticordia.com}{\texttt{lucca@verticordia.com}}}
}

\date{\today}

% =========================
% Documento
% =========================
\begin{document}

\maketitle

\begin{abstract}

    Esse trabalho aprofunda os conhecimentos sobre a linguagem de programa√ß√£o
    Rust. Nele, ser√° apresentada a hist√≥ria de tal c√≥digo, junto da cria√ß√£o de
    um panorama da mesma, colaborando para um melhor entendimento de suas
    aplica√ß√µes e utilidades, tanto atuais quanto ao longo da hist√≥ria. Al√©m
    disso, o grupo trar√° exemplos para realizar uma an√°lise de sua
    implementa√ß√£o, mostrando o uso da linguagem e seus paradigmas diante de
    pr√°ticas cotidianas e mais avan√ßadas. Por fim, ser√° posto em evid√™ncia a
    import√¢ncia da linguagem em quest√£o para a fomenta√ß√£o de outras e seu
    impacto na hist√≥ria do desenvolvimento tecnol√≥gico.

\end{abstract}

% \chapter{Introdu√ß√£o}
%
% O primeiro par√°grafo de cada se√ß√£o n√£o deve ser indentado. Este modelo segue as
% especifica√ß√µes oficiais da SBC para artigos submetidos.
%
% Os par√°grafos subsequentes devem ter uma indenta√ß√£o de 1,27 cm no in√≠cio da
% primeira linha, conforme as regras estabelecidas.
%
% \chapter{Panorama geral}
%
% Nesta se√ß√£o ser√° apresentada uma vis√£o geral sobre a hist√≥ria da linguagem
% Rust, suas influ√™ncias e o contexto de seu surgimento no cen√°rio da programa√ß√£o
% moderna.
%
% \chapter{Aplica√ß√µes e mercado}
%
% Aqui ser√£o discutidas as principais √°reas de aplica√ß√£o da linguagem Rust, bem
% como sua presen√ßa no mercado de tecnologia e em projetos de c√≥digo aberto.

\chapter{Classifica√ß√£o e Paradigmas}

\section{Introdu√ß√£o}

% TODO: revisar se essa introdu√ß√£o n√£o repete muito do que ser√° dito acima

Rust √© uma linguagem compilada de prop√≥sito geral orientada ao desenvolvimento
de sistemas---isso √©, orientada √†quelas aplica√ß√µes em que o desempenho do
programa √© altamente valorizado---geralmente compreendida como uma alternativa
moderna e funcional a C++ que minimiza os riscos associados √† ger√™ncia manual
de mem√≥ria, por meio de uma variedade de abstra√ß√µes, sem sacrificar desempenho
\cite[Pref√°cio]{blandy2021programming}. A linguagem segue a mesma ambi√ß√£o
proposta pelo autor de C++:

\begin{quote}
    Em geral, implementa√ß√µes de C++ seguem o princ√≠pio do
    \textit{zero-overhead}: voc√™ n√£o paga pelo que n√£o usa. E, al√©m disso,
    aquilo que voc√™ usa n√£o poderia ser implementado manualmente de forma
    melhor. \cite{stroustrup2004abstraction} (tradu√ß√£o livre)
\end{quote}

Apesar disso, o Rust n√£o se limita apenas √† programa√ß√£o de sistemas
operacionais, sistemas embarcados, e outras aplica√ß√µes de \textit{baixo n√≠vel}:
suas caracter√≠sticas ergon√¥micas e sua flexibilidade possibilitam o
desenvolvimento de servidores web, ferramentas para \textit{DevOps}, interfaces
gr√°ficas, aplica√ß√µes de web \textit{back end} e---por meio de \textit{web
assembly}---\textit{front end}, jogos digitais, bancos de dados, compiladores,
aplicativos m√≥veis, an√°lise e transcodifica√ß√£o de multim√≠dia, criptomoedas,
programas ass√≠ncronos, aplica√ß√µes de bioinform√°tica, ferramentas de busca,
sistemas \textsc{IoT}, aprendizado de m√°quina, navegadores, \textit{et cetera}.
Seu ecossistema, j√° amadurecido, inclui uma variedade de bibliotecas para os
desenvolvedores, al√©m de um ferramental integrado, que incorpora servidores
\textit{Language Server Protocol} (\textsc{lsp}) para integra√ß√£o com
\textsc{ide}s, formatadores de c√≥digo, e resolu√ß√£o autom√°tica e controle de
vers√µes de depend√™ncias. \cite[Introdu√ß√£o]{klabnik2021rust}

\section{Sintaxe B√°sica}

A grosso modo, a linguagem disp√µe de uma sintaxe familiar e \textit{C-like}, e
segue um paradigma \textit{imperativo e estruturado}, com certas
caracter√≠sticas procedurais cl√°ssicas, e outras funcionais modernas. A tipagem
√© est√°tica e extremamente r√≠gida, para providenciar seguran√ßa a tempo de
compila√ß√£o, mas o compilador √© capaz de inferir o tipo de uma vari√°vel usando
\textit{infer√™ncia bidirecional} \cite{pierce2000local}. No exemplo abaixo,
usamos a palavra \mintinline{rust}{fn} para declarar uma fun√ß√£o
\mintinline{rust}{main}, que n√£o recebe par√¢metros, e marca o ponto de entrada
do programa---nela, usamos a palavra \mintinline{rust}{let} para declarar uma
vari√°vel \texttt{x}, e em seguida o macro \mintinline{rust}{println!()} exibe o
valor dessa vari√°vel na sa√≠da padr√£o.\endnote{O ponto de exclama√ß√£o indica que
\mintinline{rust}{println!()} n√£o √© uma fun√ß√£o, mas um macro: no Rust, muitas
funcionalidades s√£o implementadas por meio de metaprograma√ß√£o com macros
sofisticados, que permitem que o compilador otimize ao m√°ximo at√© mesmo as
opera√ß√µes mais simples. Nesse caso, o macro √© executado a tempo de compila√ß√£o,
e √© o \textit{compilador} que gera o c√≥digo que converte nosso inteiro para uma
string a ser exibida---ou seja, √© muito mais eficiente que um
\texttt{printf()} em uma linguagem tradicional, que decide como fazer a
convers√£o a tempo de execu√ß√£o. O t√≥pico de metaprograma√ß√£o √© extenso e
complexo, mas √© interessante ressaltar que tudo ocorre a tempo de compila√ß√£o: o
compilador compila o c√≥digo-fonte do macro, gera uma biblioteca compartilhada,
carrega ela dinamicamente, e a usa para gerar o c√≥digo de m√°quina apropriado
toda vez que o macro √© referenciado. \cite[cap.~7]{gjengset2021rust}} O tipo de
\texttt{x} √© inferido como \mintinline{rust}{i32}, um n√∫mero inteiro de 32
bits, com sinal.\endnote{H√° uma variedade de tipos escalares padr√£o, mas, em
geral, tipos num√©ricos t√™m tamanhos expl√≠citos: \mintinline{rust}{u16} √© um
\textit{unsigned} de 16 bits, \mintinline{rust}{u8} √© um \textit{byte}
individual, \mintinline{rust}{f64} √© um \textit{float} de 64 bits,
\mintinline{rust}{isize} √© um \textit{signed} cujo tamanho √© igual ao tamanho
de uma palavra na arquitetura atual, e assim por diante.}

\begin{minted}{rust}
    fn main() {
        let x = 5;
        println!("O valor de ‚Äòx‚Äô √©: {x}");
    }
\end{minted}

Todas as vari√°veis s√£o imut√°veis por padr√£o. Para modific√°-las, √© preciso
declar√°-las mut√°veis com a palavra \mintinline{rust}{mut}. Tamb√©m √© poss√≠vel
especificar o tipo da vari√°vel ap√≥s seu  nome na declara√ß√£o, como se faz em
Python ou TypeScript. No exemplo abaixo, declaramos a vari√°vel \textit{mut√°vel}
\texttt{c} com tipo \mintinline{rust}{char}---isso √©, um caractere
\textsc{utf}-8.\endnote{Para ser mais exato, um \mintinline{rust}{char} √© um
\textit{code point} especificado pelo padr√£o \textsc{utf}-8 \cite[¬ß1]{rfc3629},
e n√£o um \textit{grapheme cluster} do padr√£o Unicode \cite[¬ß3]{uax29}. A
distin√ß√£o √© sutil, mas importante para internacionaliza√ß√£o da linguagem.
\cite[cap.~3, ¬ß3]{blandy2021programming}}

\begin{minted}{rust}
    fn main() {
        let mut c: char = 'üêç';
        println!("O valor de ‚Äòc‚Äô inicialmente √©: {c}");
        c = 'ü¶Ä'; // Modificar a vari√°vel s√≥ √© poss√≠vel pois usamos ‚Äòmut‚Äô acima.
        println!("O valor de ‚Äòc‚Äô modificado √©: {c}");
    }
\end{minted}

% TODO: verificar se realmente falaremos sobre os diferentes tipos de string

Isso vale n√£o somente para os tipos primitivos, mas tamb√©m para os tipos
compostos. H√° tr√™s tipos compostos padr√£o que podem estar na \textit{stack}:
tuplas, arrays, e slices. Uma tupla √© um agrupamento composto de valores de
tipos variados com tamanho fixo---uma vez criada, o seu tamanho n√£o pode mudar.
Elas podem ser declaradas listando seus itens, separados por v√≠rgulas, entre
par√™nteses, e seus elementos podem ser acessados com um ponto (\texttt{.})
seguido de um √≠ndice num√©rico, ou por desestrutura√ß√£o. J√° um array √© um
agrupamento cont√≠guo de elementos do mesmo tipo; seu tamanho tamb√©m √© fixo, e
seus elementos s√£o acessados com um √≠ndice num√©rico entre colchetes, com
verifica√ß√£o do √≠ndice feita automaticamente para impedir acessos \textit{out of
bounds}. Uma slice, por outro lado, √© um tipo de \textit{refer√™ncia} (que em
Rust chamamos de \textit{empr√©stimo} ou \textit{borrow}) \cite[cap.~16,
¬ß5]{google2024comp}, declarada prefixando o tipo com o caractere \texttt{\&},
que aponta para uma sequ√™ncia cont√≠gua de elementos.\endnote{A fim de exemplo,
podemos declarar uma refer√™ncia a um tipo primitivo assim:
\mintinline{rust}{let b: &i32 = &a}. Com isso, declaramos uma vari√°vel
\texttt{b}, de tipo \mintinline{rust}{&i32} (isso √©, uma refer√™ncia ou
\textit{empr√©stimo} de um inteiro de 32 bits com sinal), que aponta para uma
vari√°vel \texttt{a}, de tipo \mintinline{rust}{i32}. Por outro lado, se
declaramos \mintinline{rust}{let b: &[i32] = &a}, temos uma \textit{slice} de
um array de \mintinline{rust}{i32}s: um empr√©stimo de um segmento cont√≠guo da
mem√≥ria que cont√©m zero ou mais elementos do tipo \mintinline{rust}{i32}. O
\textit{borrow checker} do Rust, que discutiremos mais adiante, assegura que o
empr√©stimo seja v√°lido, e impede que a slice seja usada se o dado referenciado
deixar de existir---essa garantia √© feita a tempo de compila√ß√£o. Diferentemente
de uma refer√™ncia simples, a slice tamb√©m carrega informa√ß√µes de comprimento
(\texttt{len}) e capacidade.} No exemplo a seguir, uma tupla contendo um
inteiro, uma \textit{string slice},\endnote{Mais adiante, explicaremos os
diferentes tipos de strings em Rust, para esclarecer porque e quando usamos
\mintinline{rust}{String}, \mintinline{rust}{&str}, \mintinline{rust}{CStr},
\mintinline{rust}{OsStr}, \mintinline{rust}{OsString}, \mintinline{rust}{Path},
\mintinline{rust}{PathBuf}, \textit{et cetera}.} e um booleano √© declarada,
acessada e desestruturada; abaixo, criamos um array mut√°vel de
\textit{doubles}, alteramos um elemento, e depois criamos uma slice
n√£o-mut√°vel, que referencia os elementos da segunda √† quarta posi√ß√£o no array
(√≠ndices 1 a 3):

\begin{minted}{rust}
    fn main() {
        // Criamos uma tupla, com tr√™s elementos de diferentes tipos
        let minha_tupla: (i32, &str, bool) = (47, "Hello, World!", false);
        println!("Item na posi√ß√£o 1 da tupla: {}", minha_tupla.1);

        // Desestruturamos a tupla, criando tr√™s vari√°veis individuais
        let (num, string, booleano) = minha_tupla;
        println!("Vari√°veis: ({}, {}, {})", num, string, booleano);

        // Criamos um array mut√°vel com capacidade para cinco floats de 64 bits
        let mut meu_array: [f64; 5] = [0.1, 1.0, 1.5, 7.25, 1e100];
        meu_array[0] = 3.14;
        println!("Item no √≠ndice 0 do array: {}", meu_array[0]);

        // Criamos uma refer√™ncia imut√°vel que ‚Äòenxerga‚Äô os √≠ndices 1 a 3 do array
        let minha_slice: &[f64] = &meu_array[1..4];
        println!("Item no √≠ndice 2 da slice: {}", minha_slice[2]);
    }
\end{minted}

\section{Instru√ß√µes como Express√µes}

\subsection{Fun√ß√µes e Condicionais}

Em Rust, todo e qualquer bloco de c√≥digo  delimitado por chaves, como o corpo
de uma fun√ß√£o ou de um condicional, pode ser uma \textit{express√£o}. Em outras
palavras, sempre que h√° um bloco com chaves, √© poss√≠vel \textit{retornar um
valor}, desde que apare√ßa em um contexto onde um valor √© esperado. Isso vale
para condicionais, la√ßos com \mintinline{rust}{break} valorado, e blocos de
\textit{pattern matching}. Em geral, n√£o √© necess√°rio usar a palavra
\mintinline{rust}{return}, a menos que desejemos retornar um valor que n√£o est√°
\textit{ao final} do bloco; em geral, basta especificar a express√£o a ser
retornada ao final do bloco, sem o ponto e v√≠rgula. Um bloco que n√£o cont√©m um
\mintinline{rust}{return}, e que termina com ponto e v√≠rgula, implicitamente
retorna um \mintinline{rust}{()}, que √© o tipo vazio, ou \mintinline{c}{void},
do Rust.\endnote{Tecnicamente, o \mintinline{rust}{()} √© o \textit{valor
unit√°rio}---ele pertence ao \textit{tipo unit√°rio}, que s√≥ tem um valor
poss√≠vel, ent√£o geralmente n√£o fazemos distin√ß√£o entre o \textit{tipo} e o seu
\textit{valor}. Nos exemplos que mostramos acima, declaramos a fun√ß√£o principal
como \mintinline{rust}{fn main() {}}, mas nada nos impede de explicitar o tipo
de retorno vazio com \mintinline{rust}{fn main() -> () {}}.} Por exemplo, se
quisermos implementar uma fun√ß√£o recursiva para computar o fatorial de um
\mintinline{rust}{u32}, as tr√™s vers√µes abaixo s√£o sintaticamente
equivalentes.\endnote{Na verdade, como o Rust herda muito das linguagens
funcionais, a terceira abordagem, cuja sintaxe √© mais limpa e
\textit{declarativa}, tende a ser preferida, e o ferramental integrado da
linguagem provavelmente reclamar√° se o seu projeto incluir fun√ß√µes que usam a
palavra \mintinline{rust}{return} desnecessariamente.} \cite[cap.~3,
¬ß3]{klabnik2021rust}

\begin{minted}{rust}
    // Note que o tipo de retorno √© indicado com uma seta, ap√≥s os argumentos
    fn factorial(x: u32) -> u32 {
        if x <= 1 {
            return 1;
        } else {
            return x * factorial(x - 1);
        }
    }
\end{minted}

\begin{minted}{rust}
    fn factorial(x: u32) -> u32 {
        let result = if x <= 1 { 1 } else { x * factorial(x - 1) };
        return result;
    }
\end{minted}

\begin{minted}{rust}
    fn factorial(x: u32) -> u32 {
        if x <= 1 { 1 } else { x * factorial(x - 1) }
    }
\end{minted}

No terceiro exemplo, a express√£o \mintinline{rust}{if}-\mintinline{rust}{else}
retorna um valor, que ser√° determinado pela condi√ß√£o: se \mintinline{rust}{x <=
1}, o primeiro bloco √© avaliado, e o \mintinline{rust}{1} ser√° retornado, j√°
que √© a √∫nica express√£o nele, e n√£o precede um ponto e v√≠rgula---caso
contr√°rio, o segundo bloco √© avaliado. Pode-se entender, observando o
aninhamento dos blocos com chaves na fun√ß√£o, que cada \textit{branch} da
condicional pode retornar um valor, a express√£o condicional \textit{em si}
tamb√©m retorna um valor, e a fun√ß√£o, que s√≥ cont√©m essa express√£o condicional,
retornar√° o mesmo que ela. Note que, como os blocos que seguem os condicionais
\mintinline{rust}{if c1 {} else if c2 {} else {}} s√£o express√µes, as chaves s√£o
obrigat√≥rias, enquanto a condi√ß√£o em si √© uma express√£o simples, e n√£o precisa
de par√™nteses como em outras linguagens \textit{C-like}---a obrigatoriedade das
chaves ao redor dos blocos √© suficiente para desambiguar a condi√ß√£o do
consequente.

\subsection{La√ßos de Repeti√ß√£o}

Em Rust, h√° tr√™s tipos de la√ßos de repeti√ß√£o: \mintinline{rust}{loop},
\mintinline{rust}{while} e \mintinline{rust}{for}. Desses, o la√ßo infinito
\mintinline{rust}{loop} √© o √∫nico que pode retornar um valor diferente de
\mintinline{rust}{()}, e s√≥ pode ser terminado com um
\mintinline{rust}{break}---os outros la√ßos sempre podem ser reduzidos a esse,
mas existem por conveni√™ncia e legibilidade. Um \mintinline{rust}{break} pode
opcionalmente ser \textit{valorado}---isso √©, pode receber um valor para o
\mintinline{rust}{loop} retornar---e tamb√©m pode receber um \textit{r√≥tulo},
para indicar \textit{de qual la√ßo} o programa deve sair, quando h√° ambiguidade
entre la√ßos aninhados. Um \mintinline{rust}{while} funciona como em qualquer
outra linguagem, repetindo o bloco at√© que sua condi√ß√£o seja falsa, e um
\mintinline{rust}{for} itera sobre os elementos de um valor iter√°vel, como um
array, um vetor\endnote{At√© ent√£o, s√≥ mencionamos tipos que vivem na stack, mas
a biblioteca padr√£o do Rust disp√µe de uma variedade de tipos para dados no
heap, sempre seguindo o conceito de \textit{posse} e \textit{empr√©stimo}
(explicado adiante, e semelhante ao \textsc{raii} com \textit{move semantics}
em C++ moderno). O vetor \mintinline{rust}{Vec<T>}, do m√≥dulo
\mintinline{rust}{std::vec}, tem capacidade mut√°vel e faz ger√™ncia autom√°tica
da mem√≥ria. \cite[cap.~8, ¬ß1]{klabnik2021rust}
\cite[\stddoc{vec/struct.Vec.html\#capacity-and-reallocation}{\protect\mintinline{rust}{struct std::vec::Vec},
¬ß4}]{rust_std_doc}}, um dicion√°rio, \textit{et cetera}. No exemplo abaixo (que
n√£o √© o mais eficiente, mas ilustra bem o conceito), implementamos uma fun√ß√£o
que recebe, por empr√©stimo, uma matriz de doubles---um vetor de vetores
\mintinline{rust}{Vec<Vec<f64>>}---busca um certo elemento \mintinline{rust}{x:
f64} nela, e retorna opcionalmente\endnote{O tipo \mintinline{rust}{Option<T>}
√© um \textit{enum}, ou \textit{tipo de enumera√ß√£o}, amplamente usado na
biblioteca padr√£o. Se um \mintinline{rust}{struct} pode ser entendido como uma
\textit{conjun√ß√£o} de v√°rios valores ou atributos agrupados, um
\mintinline{rust}{enum} pode ser entendido como a \textit{disjun√ß√£o} de v√°rios
valores poss√≠veis. No caso do \mintinline{rust}{Option<T>}, ele s√≥ pode ter
dois valores: \mintinline{rust}{None} ou \mintinline{rust}{Some<T>}. Isso √©,
ele representa \textit{nenhum valor} ou \textit{um valor de tipo
\mintinline{rust}{T}}. Usa-se no lugar de um \mintinline{java}{null} de
linguagens t√≠picas, j√° que este introduz dificuldades graves de garantir a
seguran√ßa e a corretude do programa. \cite[cap.~6, ¬ß1.2]{klabnik2021rust}
\cite[\stddoc{option/index.html}{\protect\mintinline{rust}{mod std::option}}]{rust_std_doc}}
as coordenadas, se encontrado, como uma tupla \mintinline{rust}{(usize,
usize)}.\endnote{Usa-se \mintinline{rust}{usize} pois o √≠ndice de um vetor ou
de um array representa um deslocamento relativo a algum endere√ßo em mem√≥ria,
ent√£o seu tamanho depende da arquitetura. √â semelhante ao uso de
\mintinline{c}{size_t} em C, apesar de que, na pr√°tica, programas em C
frequentemente optam por usar \mintinline{c}{int}s por conven√ß√£o.}

\begin{minted}{rust}
    fn busca_matriz(matriz: &Vec<Vec<f64>>, x: f64) -> Option<(usize, usize)> {
        'loop_externo: loop {
            // O ‚Äòenumerate‚Äô produz o √≠ndice atual, junto ao elemento, em uma tupla
            for (i, linha) in matriz.iter().enumerate() { // Itera sobre linhas
                for (j, valor) in linha.iter().enumerate() { // Itera sobre colunas
                    // Se o nosso ‚Äòx‚Äô foi encontrado, sa√≠mos do loop externo
                    if *valor == x {
                        break 'loop_externo Some((i, j));
                    }
                }
            }

            // Se n√£o encontrado, retornamos ‚ÄòNone‚Äô
            break None; // O r√≥tulo √© desnecess√°rio aqui, pois n√£o h√° ambiguidade
        }
    }
\end{minted}

% \section{An√°lise cr√≠tica}
%
% Esta se√ß√£o apresentar√° uma an√°lise cr√≠tica da linguagem Rust, destacando tr√™s
% pontos positivos e tr√™s pontos negativos observados a partir de seu uso e das
% avalia√ß√µes da comunidade.
%
% \section{Legado e influ√™ncia}
%
% Ser√° abordado o legado deixado pelo Rust, bem como as linguagens, ferramentas e
% pr√°ticas de desenvolvimento que foram influenciadas por ele.
%
% \section{Conclus√£o}
%
% A se√ß√£o final sintetiza os principais pontos discutidos no trabalho, refor√ßando
% a relev√¢ncia da linguagem Rust no cen√°rio atual da computa√ß√£o.

\clearpage
\printendnotes

\clearpage
\printbibliography

\end{document}

% vim: et ts=4 sts=4 sw=4
