% LTeX: language=pt-BR

\documentclass[10pt,oneside,onecolumn]{report}
\input{def.tex}

\title{{\huge\bfseries Rust: Uma AnÃ¡lise da Linguagem}\\
Linguagens de ProgramaÃ§Ã£o}

\author{ % Autores
    \textsc{Amanda Canizela GuimarÃ£es} \\
    \normalsize{\href{mailto:amanda.canizela@gmail.com}{\texttt{amanda.canizela@gmail.com}}}
    \and
    \textsc{Ariel InÃ¡cio JordÃ£o Coelho} \\
    \normalsize{\href{mailto:arielijordao@gmail.com}{\texttt{arielijordao@gmail.com}}}
    \and
    \textsc{Lucca Pellegrini} \\
    \normalsize{\href{mailto:lucca@verticordia.com}{\texttt{lucca@verticordia.com}}}
}

\date{\today}

% =========================
% Documento
% =========================
\begin{document}

\maketitle

\begin{abstract}

    Esse trabalho aprofunda os conhecimentos sobre a linguagem de programaÃ§Ã£o
    Rust. Nele, serÃ¡ apresentada a histÃ³ria de tal cÃ³digo, junto da criaÃ§Ã£o de
    um panorama da mesma, colaborando para um melhor entendimento de suas
    aplicaÃ§Ãµes e utilidades, tanto atuais quanto ao longo da histÃ³ria. AlÃ©m
    disso, o grupo trarÃ¡ exemplos para realizar uma anÃ¡lise de sua
    implementaÃ§Ã£o, mostrando o uso da linguagem e seus paradigmas diante de
    prÃ¡ticas cotidianas e mais avanÃ§adas. Por fim, serÃ¡ posto em evidÃªncia a
    importÃ¢ncia da linguagem em questÃ£o para a fomentaÃ§Ã£o de outras e seu
    impacto na histÃ³ria do desenvolvimento tecnolÃ³gico.

\end{abstract}

% \chapter{IntroduÃ§Ã£o}
%
% O primeiro parÃ¡grafo de cada seÃ§Ã£o nÃ£o deve ser indentado. Este modelo segue as
% especificaÃ§Ãµes oficiais da SBC para artigos submetidos.
%
% Os parÃ¡grafos subsequentes devem ter uma indentaÃ§Ã£o de 1,27 cm no inÃ­cio da
% primeira linha, conforme as regras estabelecidas.
%
% \chapter{Panorama geral}
%
% Nesta seÃ§Ã£o serÃ¡ apresentada uma visÃ£o geral sobre a histÃ³ria da linguagem
% Rust, suas influÃªncias e o contexto de seu surgimento no cenÃ¡rio da programaÃ§Ã£o
% moderna.
%
% \chapter{AplicaÃ§Ãµes e mercado}
%
% Aqui serÃ£o discutidas as principais Ã¡reas de aplicaÃ§Ã£o da linguagem Rust, bem
% como sua presenÃ§a no mercado de tecnologia e em projetos de cÃ³digo aberto.

\chapter{ClassificaÃ§Ã£o e Paradigmas}

\section{IntroduÃ§Ã£o}

% TODO: revisar se essa introduÃ§Ã£o nÃ£o repete muito do que serÃ¡ dito acima

Rust Ã© uma linguagem compilada de propÃ³sito geral orientada ao desenvolvimento
de sistemas---isso Ã©, orientada Ã quelas aplicaÃ§Ãµes em que o desempenho do
programa Ã© altamente valorizado---geralmente compreendida como uma alternativa
moderna e funcional a C++ que minimiza os riscos associados Ã  gerÃªncia manual
de memÃ³ria, por meio de uma variedade de abstraÃ§Ãµes, sem sacrificar desempenho
\cite[PrefÃ¡cio]{blandy2021programming}. A linguagem segue a mesma ambiÃ§Ã£o
proposta pelo autor de C++:

\begin{quote}
    Em geral, implementaÃ§Ãµes de C++ seguem o princÃ­pio do
    \textit{zero-overhead}: vocÃª nÃ£o paga pelo que nÃ£o usa. E, alÃ©m disso,
    aquilo que vocÃª usa nÃ£o poderia ser implementado manualmente de forma
    melhor. \cite{stroustrup2004abstraction} (traduÃ§Ã£o livre)
\end{quote}

Apesar disso, o Rust nÃ£o se limita apenas Ã  programaÃ§Ã£o de sistemas
operacionais, sistemas embarcados, e outras aplicaÃ§Ãµes de \textit{baixo nÃ­vel}:
suas caracterÃ­sticas ergonÃ´micas e sua flexibilidade possibilitam o
desenvolvimento de servidores web, ferramentas para \textit{DevOps}, interfaces
grÃ¡ficas, aplicaÃ§Ãµes de web \textit{back end} e---por meio de \textit{web
assembly}---\textit{front end}, jogos digitais, bancos de dados, compiladores,
aplicativos mÃ³veis, anÃ¡lise e transcodificaÃ§Ã£o de multimÃ­dia, criptomoedas,
programas assÃ­ncronos, aplicaÃ§Ãµes de bioinformÃ¡tica, ferramentas de busca,
sistemas \textsc{IoT}, aprendizado de mÃ¡quina, navegadores, \textit{et cetera}.
Seu ecossistema, jÃ¡ amadurecido, inclui uma variedade de bibliotecas para os
desenvolvedores, alÃ©m de um ferramental integrado, que incorpora servidores
\textit{Language Server Protocol} (\textsc{lsp}) para integraÃ§Ã£o com
\textsc{ide}s, formatadores de cÃ³digo, e resoluÃ§Ã£o automÃ¡tica e controle de
versÃµes de dependÃªncias. \cite[IntroduÃ§Ã£o]{klabnik2021rust}

\section{Sintaxe BÃ¡sica}

A grosso modo, a linguagem dispÃµe de uma sintaxe familiar e \textit{C-like}, e
segue um paradigma \textit{imperativo e estruturado}, com certas
caracterÃ­sticas procedurais clÃ¡ssicas, e outras funcionais modernas. A tipagem
Ã© estÃ¡tica e extremamente rÃ­gida, para providenciar seguranÃ§a a tempo de
compilaÃ§Ã£o, mas o compilador Ã© capaz de inferir o tipo de uma variÃ¡vel usando
\textit{inferÃªncia bidirecional} \cite{pierce2000local}. No exemplo abaixo,
usamos a palavra \mintinline{rust}{fn} para declarar uma funÃ§Ã£o
\mintinline{rust}{main}, que nÃ£o recebe parÃ¢metros, e marca o ponto de entrada
do programa---nela, usamos a palavra \mintinline{rust}{let} para declarar uma
variÃ¡vel \texttt{x}, e em seguida o macro \mintinline{rust}{println!()} exibe o
valor dessa variÃ¡vel na saÃ­da padrÃ£o.\endnote{O ponto de exclamaÃ§Ã£o indica que
\mintinline{rust}{println!()} nÃ£o Ã© uma funÃ§Ã£o, mas um macro: no Rust, muitas
funcionalidades sÃ£o implementadas por meio de metaprogramaÃ§Ã£o com macros
sofisticados, que permitem que o compilador otimize ao mÃ¡ximo atÃ© mesmo as
operaÃ§Ãµes mais simples. Nesse caso, o macro Ã© executado a tempo de compilaÃ§Ã£o,
e Ã© o \textit{compilador} que gera o cÃ³digo que converte nosso inteiro para uma
string a ser exibida---ou seja, Ã© muito mais eficiente que um
\texttt{printf()} em uma linguagem tradicional, que decide como fazer a
conversÃ£o a tempo de execuÃ§Ã£o. O tÃ³pico de metaprogramaÃ§Ã£o Ã© extenso e
complexo, mas Ã© interessante ressaltar que tudo ocorre a tempo de compilaÃ§Ã£o: o
compilador compila o cÃ³digo-fonte do macro, gera uma biblioteca compartilhada,
carrega ela dinamicamente, e a usa para gerar o cÃ³digo de mÃ¡quina apropriado
toda vez que o macro Ã© referenciado. \cite[cap.~7]{gjengset2021rust}} O tipo de
\texttt{x} Ã© inferido como \mintinline{rust}{i32}, um nÃºmero inteiro de 32
bits, com sinal.\endnote{HÃ¡ uma variedade de tipos escalares padrÃ£o, mas, em
geral, tipos numÃ©ricos tÃªm tamanhos explÃ­citos: \mintinline{rust}{u16} Ã© um
\textit{unsigned} de 16 bits, \mintinline{rust}{u8} Ã© um \textit{byte}
individual, \mintinline{rust}{f64} Ã© um \textit{float} de 64 bits,
\mintinline{rust}{isize} Ã© um \textit{signed} cujo tamanho Ã© igual ao tamanho
de uma palavra na arquitetura atual, e assim por diante.}

\begin{minted}{rust}
    fn main() {
        let x = 5;
        println!("O valor de â€˜xâ€™ Ã©: {x}");
    }
\end{minted}

Todas as variÃ¡veis sÃ£o imutÃ¡veis por padrÃ£o. Para modificÃ¡-las, Ã© preciso
declarÃ¡-las mutÃ¡veis com a palavra \mintinline{rust}{mut}. TambÃ©m Ã© possÃ­vel
especificar o tipo da variÃ¡vel apÃ³s seu  nome na declaraÃ§Ã£o, como se faz em
Python ou TypeScript. No exemplo abaixo, declaramos a variÃ¡vel \textit{mutÃ¡vel}
\texttt{c} com tipo \mintinline{rust}{char}---isso Ã©, um caractere
\textsc{utf}-8.\endnote{Para ser mais exato, um \mintinline{rust}{char} Ã© um
\textit{code point} especificado pelo padrÃ£o \textsc{utf}-8 \cite[Â§1]{rfc3629},
e nÃ£o um \textit{grapheme cluster} do padrÃ£o Unicode \cite[Â§3]{uax29}. A
distinÃ§Ã£o Ã© sutil, mas importante para internacionalizaÃ§Ã£o da linguagem.
\cite[cap.~3, Â§3]{blandy2021programming}}

\begin{minted}{rust}
    fn main() {
        let mut c: char = 'ðŸ';
        println!("O valor de â€˜câ€™ inicialmente Ã©: {c}");
        c = 'ðŸ¦€'; // Modificar a variÃ¡vel sÃ³ Ã© possÃ­vel pois usamos â€˜mutâ€™ acima.
        println!("O valor de â€˜câ€™ modificado Ã©: {c}");
    }
\end{minted}

Isso vale nÃ£o somente para os tipos primitivos, mas tambÃ©m para os tipos
compostos. HÃ¡ trÃªs tipos compostos padrÃ£o que podem estar na \textit{stack}:
tuplas, arrays, e slices. Uma tupla Ã© um agrupamento composto de valores de
tipos variados com tamanho fixo---uma vez criada, o seu tamanho nÃ£o pode mudar.
Elas podem ser declaradas listando seus itens, separados por vÃ­rgulas, entre
parÃªnteses, e seus elementos podem ser acessados com um ponto (\texttt{.})
seguido de um Ã­ndice numÃ©rico, ou por desestruturaÃ§Ã£o. JÃ¡ um array Ã© um
agrupamento contÃ­guo de elementos do mesmo tipo; seu tamanho tambÃ©m Ã© fixo, e
seus elementos sÃ£o acessados com um Ã­ndice numÃ©rico entre colchetes, com
verificaÃ§Ã£o do Ã­ndice feita automaticamente para impedir acessos \textit{out of
bounds}. Uma slice, por outro lado, Ã© um tipo de \textit{referÃªncia} (que em
Rust chamamos de \textit{emprÃ©stimo} ou \textit{borrow}) \cite[cap.~16,
Â§5]{google2024comp}, declarada prefixando o tipo com o caractere \texttt{\&},
que aponta para uma sequÃªncia contÃ­gua de elementos.\endnote{A fim de exemplo,
podemos declarar uma referÃªncia a um tipo primitivo assim:
\mintinline{rust}{let b: &i32 = &a}. Com isso, declaramos uma variÃ¡vel
\texttt{b}, de tipo \mintinline{rust}{&i32} (isso Ã©, uma referÃªncia ou
\textit{emprÃ©stimo} de um inteiro de 32 bits com sinal), que aponta para uma
variÃ¡vel \texttt{a}, de tipo \mintinline{rust}{i32}. Por outro lado, se
declaramos \mintinline{rust}{let b: &[i32] = &a}, temos uma \textit{slice} de
um array de \mintinline{rust}{i32}s: um emprÃ©stimo de um segmento contÃ­guo da
memÃ³ria que contÃ©m zero ou mais elementos do tipo \mintinline{rust}{i32}. O
\textit{borrow checker} do Rust, que discutiremos mais adiante, assegura que o
emprÃ©stimo seja vÃ¡lido, e impede que a slice seja usada se o dado referenciado
deixar de existir---essa garantia Ã© feita a tempo de compilaÃ§Ã£o. Diferentemente
de uma referÃªncia simples, a slice tambÃ©m carrega informaÃ§Ãµes de comprimento
(\texttt{len}) e capacidade.} No exemplo a seguir, uma tupla contendo um
inteiro, uma \textit{string slice},\endnote{Mais adiante, explicaremos os
diferentes tipos de strings em Rust, para esclarecer porque e quando usamos
\mintinline{rust}{String}, \mintinline{rust}{&str}, \mintinline{rust}{CStr},
\mintinline{rust}{OsStr}, \mintinline{rust}{OsString}, \mintinline{rust}{Path},
\mintinline{rust}{PathBuf}, \textit{et cetera}.} e um booleano Ã© declarada,
acessada e desestruturada; abaixo, criamos um array mutÃ¡vel de
\textit{doubles}, alteramos um elemento, e depois criamos uma slice
nÃ£o-mutÃ¡vel, que referencia os elementos da segunda Ã  quarta posiÃ§Ã£o no array
(Ã­ndices 1 a 3):

\begin{minted}{rust}
    fn main() {
        // Criamos uma tupla, com trÃªs elementos de diferentes tipos
        let minha_tupla: (i32, &str, bool) = (47, "Hello, World!", false);
        println!("Item na posiÃ§Ã£o 1 da tupla: {}", minha_tupla.1);

        // Desestruturamos a tupla, criando trÃªs variÃ¡veis individuais
        let (num, string, booleano) = minha_tupla;
        println!("VariÃ¡veis: ({}, {}, {})", num, string, booleano);

        // Criamos um array mutÃ¡vel com capacidade para cinco floats de 64 bits
        let mut meu_array: [f64; 5] = [0.1, 1.0, 1.5, 7.25, 1e100];
        meu_array[0] = 3.14;
        println!("Item no Ã­ndice 0 do array: {}", meu_array[0]);

        // Criamos uma referÃªncia imutÃ¡vel que â€˜enxergaâ€™ os Ã­ndices 1 a 3 do array
        let minha_slice: &[f64] = &meu_array[1..4];
        println!("Item no Ã­ndice 2 da slice: {}", minha_slice[2]);
    }
\end{minted}

\section{InstruÃ§Ãµes como ExpressÃµes}

Em Rust, todo e qualquer bloco de cÃ³digo  delimitado por chaves, como o corpo
de uma funÃ§Ã£o ou de um condicional, pode ser uma \textit{expressÃ£o}. Em outras
palavras, sempre que hÃ¡ um bloco com chaves, Ã© possÃ­vel \textit{retornar um
valor}, desde que apareÃ§a em um contexto onde um valor Ã© esperado. Isso vale
para condicionais, laÃ§os com \mintinline{rust}{break} valorado, e blocos de
\textit{pattern matching}. Em geral, nÃ£o Ã© necessÃ¡rio usar a palavra
\mintinline{rust}{return}, a menos que desejemos retornar um valor que nÃ£o estÃ¡
\textit{ao final} do bloco; em geral, basta especificar a expressÃ£o a ser
retornada ao final do bloco, sem o ponto e vÃ­rgula. Um bloco que nÃ£o contÃ©m um
\mintinline{rust}{return}, e que termina com ponto e vÃ­rgula, implicitamente
retorna um \mintinline{rust}{()}, que Ã© o tipo vazio, ou \mintinline{c}{void},
do Rust.\endnote{Tecnicamente, o \mintinline{rust}{()} Ã© o \textit{valor
unitÃ¡rio}---ele pertence ao \textit{tipo unitÃ¡rio}, que sÃ³ tem um valor
possÃ­vel, entÃ£o geralmente nÃ£o fazemos distinÃ§Ã£o entre o \textit{tipo} e o seu
\textit{valor}. Nos exemplos que mostramos acima, declaramos a funÃ§Ã£o principal
como \mintinline{rust}{fn main() {}}, mas nada nos impede de explicitar o tipo
de retorno vazio com \mintinline{rust}{fn main() -> () {}}.} Por exemplo, se
quisermos implementar uma funÃ§Ã£o recursiva para computar o fatorial de um
\mintinline{rust}{u32}, as trÃªs versÃµes abaixo sÃ£o sintaticamente
equivalentes.\endnote{Na verdade, como o Rust herda muito das linguagens
funcionais, a terceira abordagem, cuja sintaxe Ã© mais limpa e
\textit{declarativa}, tende a ser preferida, e o ferramental integrado da
linguagem provavelmente reclamarÃ¡ se o seu projeto incluir funÃ§Ãµes que usam a
palavra \mintinline{rust}{return} desnecessariamente.} \cite[cap.~3,
Â§3]{klabnik2021rust}

\begin{minted}{rust}
    // Note que o tipo de retorno Ã© indicado com uma seta, apÃ³s os argumentos
    fn factorial(x: u32) -> u32 {
        if x <= 1 {
            return 1;
        } else {
            return x * factorial(x - 1);
        }
    }
\end{minted}

\begin{minted}{rust}
    fn factorial(x: u32) -> u32 {
        let result = if x <= 1 { 1 } else { x * factorial(x - 1) };
        return result;
    }
\end{minted}

\begin{minted}{rust}
    fn factorial(x: u32) -> u32 {
        if x <= 1 { 1 } else { x * factorial(x - 1) }
    }
\end{minted}

No terceiro exemplo, a expressÃ£o \mintinline{rust}{if}-\mintinline{rust}{else}
retorna um valor, que serÃ¡ determinado pela condiÃ§Ã£o: se \mintinline{rust}{x <=
1}, o primeiro bloco Ã© avaliado, e o \mintinline{rust}{1} serÃ¡ retornado, jÃ¡
que Ã© a Ãºnica expressÃ£o nele, e nÃ£o precede um ponto e vÃ­rgula---caso
contrÃ¡rio, o segundo bloco Ã© avaliado. Pode-se entender, observando o
aninhamento dos blocos com chaves na funÃ§Ã£o, que cada \textit{branch} da
condicional pode retornar um valor, a expressÃ£o condicional \textit{em si}
tambÃ©m retorna um valor, e a funÃ§Ã£o, que sÃ³ contÃ©m essa expressÃ£o condicional,
retornarÃ¡ o mesmo que ela.

% \section{AnÃ¡lise crÃ­tica}
%
% Esta seÃ§Ã£o apresentarÃ¡ uma anÃ¡lise crÃ­tica da linguagem Rust, destacando trÃªs
% pontos positivos e trÃªs pontos negativos observados a partir de seu uso e das
% avaliaÃ§Ãµes da comunidade.
%
% \section{Legado e influÃªncia}
%
% SerÃ¡ abordado o legado deixado pelo Rust, bem como as linguagens, ferramentas e
% prÃ¡ticas de desenvolvimento que foram influenciadas por ele.
%
% \section{ConclusÃ£o}
%
% A seÃ§Ã£o final sintetiza os principais pontos discutidos no trabalho, reforÃ§ando
% a relevÃ¢ncia da linguagem Rust no cenÃ¡rio atual da computaÃ§Ã£o.

\clearpage
\printendnotes

\clearpage
\printbibliography

\end{document}

% vim: et ts=4 sts=4 sw=4
