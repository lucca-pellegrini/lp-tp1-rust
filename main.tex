% LTeX: language=pt-BR

\documentclass[10pt,oneside,onecolumn]{article}
\input{def.tex}

\title{{\huge\bfseries Rust: Uma An√°lise da Linguagem}\\
Linguagens de Programa√ß√£o}

\author{ % Autores
    \textsc{Amanda Canizela Guimar√£es} \\
    \normalsize{\href{mailto:amanda.canizela@gmail.com}{\texttt{amanda.canizela@gmail.com}}}
    \and
    \textsc{Ariel In√°cio Jord√£o Coelho} \\
    \normalsize{\href{mailto:arielijordao@gmail.com}{\texttt{arielijordao@gmail.com}}}
    \and
    \textsc{Lucca Pellegrini} \\
    \normalsize{\href{mailto:lucca@verticordia.com}{\texttt{lucca@verticordia.com}}}
}

\date{\today}

% =========================
% Documento
% =========================
\begin{document}

\maketitle

\begin{abstract}

    Esse trabalho aprofunda os conhecimentos sobre a linguagem de programa√ß√£o
    Rust. Nele, ser√° apresentada a hist√≥ria de tal c√≥digo, junto da cria√ß√£o de
    um panorama da mesma, colaborando para um melhor entendimento de suas
    aplica√ß√µes e utilidades, tanto atuais quanto ao longo da hist√≥ria. Al√©m
    disso, o grupo trar√° exemplos para realizar uma an√°lise de sua
    implementa√ß√£o, mostrando o uso da linguagem e seus paradigmas diante de
    pr√°ticas cotidianas e mais avan√ßadas. Por fim, ser√° posto em evid√™ncia a
    import√¢ncia da linguagem em quest√£o para a fomenta√ß√£o de outras e seu
    impacto na hist√≥ria do desenvolvimento tecnol√≥gico.

\end{abstract}

\section{Introdu√ß√£o}

O primeiro par√°grafo de cada se√ß√£o n√£o deve ser indentado. Este modelo segue as
especifica√ß√µes oficiais da SBC para artigos submetidos.

Os par√°grafos subsequentes devem ter uma indenta√ß√£o de 1,27 cm no in√≠cio da
primeira linha, conforme as regras estabelecidas.

\section{Panorama geral}

Nesta se√ß√£o ser√° apresentada uma vis√£o geral sobre a hist√≥ria da linguagem
Rust, suas influ√™ncias e o contexto de seu surgimento no cen√°rio da programa√ß√£o
moderna.

\section{Aplica√ß√µes e mercado}

Aqui ser√£o discutidas as principais √°reas de aplica√ß√£o da linguagem Rust, bem
como sua presen√ßa no mercado de tecnologia e em projetos de c√≥digo aberto.

\section{Classifica√ß√£o e Paradigmas}

\subsection{Introdu√ß√£o}

% TODO: revisar se essa introdu√ß√£o n√£o repete muito do que ser√° dito acima

Rust √© uma linguagem compilada de prop√≥sito geral orientada ao desenvolvimento
de sistemas---isso √©, orientada √†quelas aplica√ß√µes em que o desempenho do
programa √© altamente valorizado---geralmente compreendida como uma alternativa
moderna e funcional a C++ que minimiza os riscos associados √† ger√™ncia manual
de mem√≥ria, por meio de uma variedade de abstra√ß√µes, sem sacrificar desempenho
\cite[Pref√°cio]{blandy2021programming}. A linguagem segue a mesma ambi√ß√£o
proposta pelo autor de C++:

\begin{quote}
    Em geral, implementa√ß√µes de C++ seguem o princ√≠pio do
    \textit{zero-overhead}: voc√™ n√£o paga pelo que n√£o usa. E, al√©m disso,
    aquilo que voc√™ usa n√£o poderia ser implementado manualmente de forma
    melhor. \cite{stroustrup2004abstraction} (tradu√ß√£o livre)
\end{quote}

Apesar disso, o Rust n√£o se limita apenas √† programa√ß√£o de sistemas
operacionais, sistemas embarcados, e outras aplica√ß√µes de \textit{baixo n√≠vel}:
suas caracter√≠sticas ergon√¥micas e sua flexibilidade possibilitam o
desenvolvimento de servidores web, ferramentas para \textit{DevOps}, interfaces
gr√°ficas, aplica√ß√µes web \textit{back end} e---por meio de \textit{web
assembly}---\textit{front end}, jogos digitais, bancos de dados, compiladores,
aplicativos m√≥veis, an√°lise e transcodifica√ß√£o de multim√≠dia, criptomoedas,
programas ass√≠ncronos, aplica√ß√µes de bioinform√°tica, ferramentas de busca,
sistemas \textsc{IoT}, aprendizado de m√°quina, navegadores, \textit{et cetera}.
Seu ecossistema, j√° amadurecido, inclui uma variedade de bibliotecas para os
desenvolvedores, al√©m de um ferramental integrado, que incorpora servidores
\textit{Language Server Protocol} (\textsc{lsp}) para integra√ß√£o com
\textsc{ide}s, formatadores de c√≥digo, e resolu√ß√£o autom√°tica e controle de
vers√µes de depend√™ncias. \cite[Introdu√ß√£o]{klabnik2021rust}

% TODO: revisar se o par√°grafo abaixo √© realmente necess√°rio...

Nesta se√ß√£o, exploraremos os fundamentos da sintaxe e dos paradigmas que
definem o Rust atrav√©s de exemplos pr√°ticos de c√≥digo. O objetivo n√£o √©
fornecer um tutorial completo ou exaustivo sobre a linguagem, mas ilustrar seus
principais conceitos e mecanismos por meio de exemplos sintaticamente corretos
e compil√°veis na vers√£o mais recente da linguagem. Abordaremos desde a sintaxe
b√°sica---declara√ß√£o de vari√°veis, tipos primitivos e compostos---at√© conceitos
mais avan√ßados como o sistema de \textit{ownership}, \textit{borrowing}, e
\textit{lifetimes}, que constituem o cora√ß√£o da proposta inovadora do Rust para
gerenciamento seguro de mem√≥ria. Tamb√©m discutiremos brevemente as
caracter√≠sticas funcionais da linguagem, como \textit{pattern matching},
\textit{iterators}, \textit{closures} e programa√ß√£o gen√©rica. √â importante
ressaltar que os exemplos apresentados s√£o ilustrativos e did√°ticos, destinados
a demonstrar a sintaxe e os conceitos fundamentais, e n√£o constituem
necessariamente c√≥digo de produ√ß√£o. Para um aprendizado aprofundado sobre
\textit{como} programar em Rust e aplicar seus conceitos em projetos reais,
recomenda-se fortemente a consulta √†s refer√™ncias bibliogr√°ficas citadas ao
longo do texto, em especial os livros \cite{klabnik2021rust} e
\cite{blandy2021programming}, que oferecem cobertura abrangente e did√°tica da
linguagem.

\subsection{Sintaxe B√°sica}

A grosso modo, a linguagem disp√µe de uma sintaxe familiar e \textit{C-like}, e
segue um paradigma \textit{imperativo e estruturado}, com certas
caracter√≠sticas procedurais cl√°ssicas, e outras funcionais modernas. A tipagem
√© est√°tica e extremamente r√≠gida, para providenciar seguran√ßa a tempo de
compila√ß√£o, mas o compilador √© capaz de inferir o tipo de uma vari√°vel usando
\textit{infer√™ncia bidirecional} \cite{pierce2000local}. No exemplo abaixo,
usamos a palavra \mintinline{rust}{fn} para declarar uma fun√ß√£o
\mintinline{rust}{main}, que n√£o recebe par√¢metros, e marca o ponto de entrada
do programa---nela, usamos a palavra \mintinline{rust}{let} para declarar uma
vari√°vel \texttt{x}, e em seguida o macro \mintinline{rust}{println!()} exibe o
valor dessa vari√°vel na sa√≠da padr√£o.\footnote{O ponto de exclama√ß√£o indica que
\mintinline{rust}{println!()} n√£o √© uma fun√ß√£o, mas um macro: no Rust, muitas
funcionalidades s√£o implementadas por meio de metaprograma√ß√£o com macros
sofisticados, que permitem que o compilador otimize ao m√°ximo at√© mesmo as
opera√ß√µes mais simples. Nesse caso, o macro √© executado a tempo de compila√ß√£o,
e √© o \textit{compilador} que gera o c√≥digo que converte nosso inteiro para uma
string a ser exibida---ou seja, √© muito mais eficiente que um
\texttt{printf()} em uma linguagem tradicional, que faz a convers√£o a tempo de
execu√ß√£o. \cite[cap.~7]{gjengset2021rust}} O tipo de \texttt{x} √© inferido como
\mintinline{rust}{i32}, um n√∫mero inteiro de 32 bits, com sinal.\footnote{H√°
uma variedade de tipos escalares padr√£o, mas em geral, tipos num√©ricos t√™m
tamanhos expl√≠citos: \mintinline{rust}{u16} √© um \textit{unsigned} de 16 bits,
\mintinline{rust}{u8} √© um \textit{byte} individual, \mintinline{rust}{f64} √©
um \textit{float} de 64 bits, \mintinline{rust}{isize} √© um \textit{signed}
cujo tamanho √© igual ao tamanho de uma palavra na arquitetura atual, e assim
por diante.}

\begin{minted}{rust}
    fn main() {
        let x = 5;
        println!("O valor de ‚Äòx‚Äô √©: {x}");
    }
\end{minted}

Todas as vari√°veis s√£o imut√°veis por padr√£o. Para modific√°-las, √© preciso
declar√°-las mut√°veis com a palavra \mintinline{rust}{mut}. Tamb√©m √© poss√≠vel
especificar o tipo da vari√°vel ap√≥s seu  nome na declara√ß√£o, como se faz em
Python ou TypeScript. No exemplo abaixo, declaramos a vari√°vel \textit{mut√°vel}
\texttt{c} com tipo \mintinline{rust}{char}---isso √©, um caractere
\textsc{utf}-8:\footnote{Para ser mais exato, um \mintinline{rust}{char} √© um
\textit{code point} especificado pelo padr√£o \textsc{utf}-8 \cite[¬ß1]{rfc3629},
e n√£o um \textit{grapheme cluster} do padr√£o Unicode \cite[¬ß3]{uax29}. A
distin√ß√£o √© sutil, mas importante para internacionaliza√ß√£o da linguagem.
\cite[cap.~3, ¬ß3]{blandy2021programming}}

\begin{minted}{rust}
    fn main() {
        let mut c: char = 'üêç';
        println!("O valor de ‚Äòc‚Äô inicialmente √©: {c}");
        c = 'ü¶Ä'; // Modificar a vari√°vel s√≥ √© poss√≠vel pois usamos ‚Äòmut‚Äô acima.
        println!("O valor de ‚Äòc‚Äô modificado √©: {c}");
    }
\end{minted}

Isso vale n√£o somente para os tipos primitivos, mas tamb√©m para os tipos
compostos. H√° tr√™s tipos compostos padr√£o que podem estar na \textit{stack}:
tuplas, arrays, e slices. Uma tupla √© um agrupamento composto de valores de
tipos variados com tamanho fixo---uma vez criada, o seu tamanho n√£o pode mudar.
Elas podem ser declaradas listando seus itens, separados por v√≠rgulas, entre
par√™nteses, e seus elementos podem ser acessados com um ponto (\texttt{.})
seguido de um √≠ndice num√©rico, ou por desestrutura√ß√£o. J√° um array √© um
agrupamento cont√≠guo de elementos do mesmo tipo; seu tamanho tamb√©m √© fixo, e
seus elementos s√£o acessados com um √≠ndice num√©rico entre colchetes, com
verifica√ß√£o do √≠ndice sendo feita automaticamente para impedir acessos
\textit{out of bounds}. Uma slice, por outro lado, √© um tipo de
\textit{refer√™ncia} (que em Rust chamamos de \textit{empr√©stimo} ou
\textit{borrow}) \cite[cap.~16, ¬ß5]{google2024comp}, declarada prefixando o
tipo com o caractere \texttt{\&}, que aponta para uma sequ√™ncia cont√≠gua de
elementos.\footnote{A fim de exemplo, podemos declarar uma refer√™ncia a um tipo
primitivo assim: \mintinline{rust}{let b: &i32 = &a}. Com isso, declaramos uma
vari√°vel \texttt{b}, de tipo \mintinline{rust}{&i32} (isso √©, uma refer√™ncia ou
\textit{empr√©stimo} de um inteiro de 32 bits com sinal), que aponta para uma
vari√°vel \texttt{a}, de tipo \mintinline{rust}{i32}. Por outro lado, se
declaramos \mintinline{rust}{let b: &[i32] = &a}, temos uma \textit{slice} de
um array de \mintinline{rust}{i32}s: um empr√©stimo de um segmento cont√≠guo da
mem√≥ria que cont√©m zero ou mais elementos do tipo \mintinline{rust}{i32}. O
\textit{borrow checker} do Rust, que discutiremos mais adiante, assegura que o
empr√©stimo seja v√°lido e impede que a slice seja usada se o dado referenciado
deixar de existir---essa garantia √© feita a tempo de compila√ß√£o. Diferentemente
de uma refer√™ncia simples, a slice tamb√©m carrega informa√ß√µes de comprimento
(\texttt{len}) e capacidade.} No exemplo a seguir, uma tupla contendo um
inteiro, uma \textit{string slice},\footnote{Mais adiante, explicaremos os
diferentes tipos de strings em Rust, para esclarecer por qu√™ e quando usamos
\mintinline{rust}{String}, \mintinline{rust}{&str}, \mintinline{rust}{CStr},
\mintinline{rust}{OsStr}, \mintinline{rust}{OsString}, \mintinline{rust}{Path},
\mintinline{rust}{PathBuf}, \textit{et cetera}.} e um booleano √© declarada,
acessada e desestruturada; abaixo, criamos um array mut√°vel de
\textit{doubles}, alteramos um elemento, e depois criamos uma slice
n√£o-mut√°vel, que referencia os elementos da segunda √† quarta posi√ß√£o no array
(√≠ndices 1 a 3):

\begin{minted}{rust}
    fn main() {
        // Criamos uma tupla, com tr√™s elementos de diferentes tipos
        let minha_tupla: (i32, &str, bool) = (47, "Hello, World!", false);
        println!("Item na posi√ß√£o 1 da tupla: {}", minha_tupla.1);

        // Desestruturamos a tupla, criando tr√™s vari√°veis individuais
        let (num, string, booleano) = minha_tupla;
        println!("Vari√°veis: ({}, {}, {})", num, string, booleano);

        // Criamos um array mut√°vel com capacidade para cinco floats de 64 bits
        let mut meu_array: [f64; 5] = [0.1, 1.0, 1.5, 7.25, 1e100];
        meu_array[0] = 3.14;
        println!("Item no √≠ndice 0 do array: {}", meu_array[0]);

        // Criamos uma refer√™ncia imut√°vel que ‚Äòenxerga‚Äô os √≠ndices 1 a 3 do array
        let minha_slice: &[f64] = &meu_array[1..4];
        println!("Item no √≠ndice 2 da slice: {}", minha_slice[2]);
    }
\end{minted}

\section{An√°lise cr√≠tica}

Esta se√ß√£o apresentar√° uma an√°lise cr√≠tica da linguagem Rust, destacando tr√™s
pontos positivos e tr√™s pontos negativos observados a partir de seu uso e das
avalia√ß√µes da comunidade.

\section{Legado e influ√™ncia}

Ser√° abordado o legado deixado pelo Rust, bem como as linguagens, ferramentas e
pr√°ticas de desenvolvimento que foram influenciadas por ele.

\section{Conclus√£o}

A se√ß√£o final sintetiza os principais pontos discutidos no trabalho, refor√ßando
a relev√¢ncia da linguagem Rust no cen√°rio atual da computa√ß√£o.

\clearpage
\printbibliography

\end{document}

% vim: et ts=4 sts=4 sw=4
